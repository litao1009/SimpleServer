#include "SafeIDMap.h"

#include <boost/bimap.hpp>
#include <boost/bimap/unordered_multiset_of.hpp>
#include <boost/bimap/set_of.hpp>
#include <boost/bimap/multiset_of.hpp>
#include <boost/functional/hash.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/conversion.hpp>

#include <unordered_map>
#include <unordered_set>
#include <mutex>
#include <atomic>

#include "Utils/SmartPtr.h"

#include "Codec/UserVCode.pb.h"
#include "DataBase/DataBase.h"
#include "Processor/DBValue.h"
#include "DataBase/msg-SV.h"

#include "TinyLog.h"

PRIVATE_IMPLEMENT(SafeIDMap)

typedef	boost::bimaps::tagged<SIDInfoWPtr,class IDWPtr>		TagIDWPtr;
typedef	boost::bimaps::tagged<mori::EndPoint,class EP>		TagEP;

typedef	boost::bimap<boost::bimaps::set_of<TagEP>,boost::bimaps::multiset_of<TagIDWPtr, std::owner_less<SIDInfoWPtr>>>	EPToIDMap;
typedef	std::unordered_map<AStringType, SIDInfoSPtr>			VCodeToIDMap;


static	std::atomic<uint64_t>	s_VCodeUID(0);

class	SafeIDMap::Imp
{
public:

	Imp()
	{
		unsigned char priBytes[] = 
		{
			0x30, 0x82, 0x02, 0x75, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
			0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x02, 0x5f, 0x30, 0x82, 0x02, 0x5b, 0x02, 0x01,
			0x00, 0x02, 0x81, 0x81, 0x00, 0xa0, 0x90, 0x87, 0x18, 0xff, 0x56, 0x40, 0xff, 0x5a, 0xc9, 0xfa,
			0x4e, 0x68, 0x54, 0x51, 0xf5, 0x82, 0x24, 0x00, 0x3b, 0x1d, 0x58, 0x3e, 0xb3, 0x94, 0x7e, 0x21,
			0xd6, 0x35, 0xa5, 0x2f, 0xef, 0xc9, 0xdb, 0x20, 0x8e, 0x66, 0xc1, 0x0b, 0xbe, 0x6f, 0x12, 0x86,
			0xe0, 0xd6, 0x97, 0xaf, 0xbb, 0x7c, 0xc6, 0x12, 0x74, 0x6c, 0x20, 0xce, 0xfa, 0x27, 0xad, 0x66,
			0x36, 0x66, 0xf0, 0xe3, 0x00, 0x86, 0x9a, 0x17, 0xe4, 0x27, 0x95, 0x5a, 0x6a, 0x1b, 0x5c, 0x1d,
			0xcf, 0x6c, 0xdf, 0x26, 0xc7, 0xaf, 0xbd, 0xfb, 0xf5, 0xf2, 0x09, 0xbf, 0xe0, 0x87, 0xd1, 0xd5,
			0x26, 0x79, 0xb7, 0xa6, 0x65, 0x36, 0x52, 0x46, 0x8a, 0x48, 0x8c, 0x9b, 0xa1, 0x65, 0xf2, 0x46,
			0x13, 0x39, 0xe1, 0xff, 0x77, 0x92, 0x0a, 0x37, 0x5e, 0x16, 0x35, 0xe2, 0xec, 0x4e, 0x8f, 0xc2,
			0x20, 0xb4, 0x93, 0x48, 0x8d, 0x02, 0x01, 0x11, 0x02, 0x81, 0x80, 0x33, 0xf2, 0x86, 0x0f, 0x9d,
			0xe7, 0x33, 0x25, 0x70, 0x32, 0x49, 0x73, 0xb8, 0x57, 0x83, 0xed, 0x8b, 0xfc, 0x96, 0xa9, 0xb6,
			0xab, 0x9b, 0xd0, 0xb0, 0x0a, 0xb0, 0x98, 0x20, 0x6a, 0x26, 0x18, 0xdf, 0x6c, 0x8a, 0x88, 0x6c,
			0x89, 0xc0, 0x08, 0xe7, 0xb3, 0x2b, 0xa3, 0x18, 0x40, 0x22, 0x44, 0x2f, 0xe5, 0xba, 0xad, 0x32,
			0x0a, 0x9d, 0x50, 0xee, 0xb8, 0x19, 0x8a, 0x12, 0x3e, 0xe0, 0x07, 0x2f, 0x96, 0xbb, 0x3c, 0x35,
			0xa0, 0xa2, 0x7c, 0xa0, 0xf2, 0xd0, 0x5f, 0x04, 0xf7, 0x25, 0xb2, 0xe4, 0xc6, 0xbc, 0x0a, 0x5c,
			0xc3, 0x62, 0xa4, 0xfe, 0xb7, 0x45, 0x0a, 0x30, 0xc9, 0x9d, 0xa2, 0x4c, 0x59, 0x31, 0x59, 0x7a,
			0xa2, 0x4b, 0xa9, 0x7b, 0xc9, 0x23, 0xa2, 0xac, 0xcb, 0x8a, 0x72, 0x07, 0xd3, 0x09, 0xdd, 0xa3,
			0xbd, 0x69, 0x60, 0x90, 0x56, 0xc3, 0x09, 0x5d, 0x64, 0x71, 0x0b, 0x02, 0x41, 0x00, 0xd8, 0xf9,
			0x21, 0xfb, 0x90, 0x87, 0x66, 0xbd, 0x4c, 0x3c, 0x98, 0x0b, 0x33, 0x72, 0x6b, 0xf0, 0x4d, 0x0c,
			0x4b, 0x1e, 0xd3, 0x81, 0xca, 0x04, 0x39, 0x1c, 0xf1, 0x98, 0x84, 0x36, 0xbb, 0x2e, 0xc2, 0x5b,
			0xe8, 0x16, 0x51, 0x7b, 0xb6, 0x14, 0x9e, 0x10, 0x4b, 0x70, 0x66, 0xb6, 0xe0, 0x84, 0x5d, 0x74,
			0xf4, 0x79, 0x17, 0x05, 0x2e, 0xad, 0x37, 0x04, 0xe5, 0x5c, 0xb7, 0x38, 0x8a, 0x0f, 0x02, 0x41,
			0x00, 0xbd, 0x71, 0xf8, 0xff, 0xf1, 0x4b, 0xfd, 0x71, 0x69, 0x48, 0x47, 0x87, 0x41, 0x59, 0x8c,
			0x22, 0xce, 0x1c, 0xdf, 0xfc, 0xe8, 0x89, 0x22, 0x0c, 0xde, 0x4f, 0xdf, 0x9d, 0x01, 0x9d, 0x61,
			0x12, 0x42, 0x28, 0x80, 0x19, 0x93, 0x49, 0xcd, 0x23, 0xd4, 0xe8, 0xa3, 0xc3, 0x48, 0xb5, 0xfe,
			0xaa, 0x05, 0x20, 0x3b, 0xac, 0x4a, 0xe7, 0x3f, 0xfd, 0x59, 0x67, 0x6a, 0xa7, 0x0b, 0x3b, 0x8f,
			0xa3, 0x02, 0x40, 0x59, 0x57, 0x86, 0x76, 0xa4, 0xec, 0x75, 0x99, 0x3d, 0x82, 0x5c, 0xb9, 0x51,
			0x6b, 0x59, 0x9f, 0x2e, 0xc8, 0xd3, 0xa3, 0x48, 0x08, 0x44, 0x1f, 0xdb, 0x48, 0x27, 0x3e, 0xcd,
			0x07, 0x7a, 0x40, 0x6e, 0x25, 0xd8, 0x09, 0x30, 0x9c, 0x5a, 0x08, 0x7d, 0x52, 0x00, 0xf2, 0x0c,
			0x2d, 0x2f, 0x45, 0x8f, 0xe4, 0xdd, 0x22, 0xcd, 0x3e, 0x5e, 0x83, 0x8f, 0x20, 0x22, 0x35, 0x3c,
			0x62, 0x93, 0x33, 0x02, 0x41, 0x00, 0xa7, 0x28, 0x54, 0x2d, 0x20, 0x33, 0xfd, 0xbe, 0x6b, 0xf4,
			0x7b, 0x59, 0x39, 0xa9, 0x5d, 0x88, 0x1f, 0x46, 0xa7, 0x84, 0xcd, 0x2d, 0xb4, 0xa1, 0xf1, 0x55,
			0x89, 0x12, 0x10, 0x7b, 0xce, 0x1f, 0x2b, 0x50, 0xe9, 0x7f, 0xfa, 0x6e, 0x4b, 0x98, 0x16, 0x36,
			0xae, 0x9d, 0x40, 0x28, 0x1c, 0xf0, 0x5e, 0xe0, 0x34, 0xa7, 0x14, 0xea, 0x29, 0x67, 0x12, 0xa6,
			0x8b, 0x48, 0x18, 0xf8, 0x51, 0x8f, 0x02, 0x41, 0x00, 0xa7, 0xa2, 0xf6, 0x0a, 0x5a, 0x35, 0x94,
			0x27, 0x35, 0xd7, 0x53, 0xfd, 0x80, 0x1e, 0xc7, 0x78, 0x2b, 0xfc, 0x52, 0xfb, 0x39, 0xa7, 0x5d,
			0x66, 0x21, 0x65, 0x42, 0x71, 0xfd, 0x6a, 0x18, 0xfa, 0x2a, 0x79, 0x86, 0xfe, 0x5e, 0x69, 0x56,
			0xfe, 0x4c, 0x21, 0x7a, 0x2c, 0x7c, 0xaf, 0xd6, 0xe6, 0x3a, 0xbb, 0xd2, 0x97, 0x40, 0xfa, 0xdb,
			0x64, 0x69, 0x95, 0xb9, 0x17, 0xbc, 0x6e, 0x98, 0x5c
		};

		unsigned char pubBytes[] = 
		{
			0x30, 0x81, 0x9d, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01,
			0x05, 0x00, 0x03, 0x81, 0x8b, 0x00, 0x30, 0x81, 0x87, 0x02, 0x81, 0x81, 0x00, 0xa0, 0x90, 0x87,
			0x18, 0xff, 0x56, 0x40, 0xff, 0x5a, 0xc9, 0xfa, 0x4e, 0x68, 0x54, 0x51, 0xf5, 0x82, 0x24, 0x00,
			0x3b, 0x1d, 0x58, 0x3e, 0xb3, 0x94, 0x7e, 0x21, 0xd6, 0x35, 0xa5, 0x2f, 0xef, 0xc9, 0xdb, 0x20,
			0x8e, 0x66, 0xc1, 0x0b, 0xbe, 0x6f, 0x12, 0x86, 0xe0, 0xd6, 0x97, 0xaf, 0xbb, 0x7c, 0xc6, 0x12,
			0x74, 0x6c, 0x20, 0xce, 0xfa, 0x27, 0xad, 0x66, 0x36, 0x66, 0xf0, 0xe3, 0x00, 0x86, 0x9a, 0x17,
			0xe4, 0x27, 0x95, 0x5a, 0x6a, 0x1b, 0x5c, 0x1d, 0xcf, 0x6c, 0xdf, 0x26, 0xc7, 0xaf, 0xbd, 0xfb,
			0xf5, 0xf2, 0x09, 0xbf, 0xe0, 0x87, 0xd1, 0xd5, 0x26, 0x79, 0xb7, 0xa6, 0x65, 0x36, 0x52, 0x46,
			0x8a, 0x48, 0x8c, 0x9b, 0xa1, 0x65, 0xf2, 0x46, 0x13, 0x39, 0xe1, 0xff, 0x77, 0x92, 0x0a, 0x37,
			0x5e, 0x16, 0x35, 0xe2, 0xec, 0x4e, 0x8f, 0xc2, 0x20, 0xb4, 0x93, 0x48, 0x8d, 0x02, 0x01, 0x11
		};

		CommonPriKey_ = std::move(AStringType(std::begin(priBytes),std::end(priBytes)));
		CommonPubKey_ = std::move(AStringType(std::begin(pubBytes),std::end(pubBytes)));

#ifdef NDEBUG
		try
		{
			using namespace autoDB;

			auto sql = DataBase::CreateSession();
			Statement st;

			st.Update(SV_UserLoginStatusInfo.LoginStatus.Use(DBValue::LoginStatus::Logout));

			SociAdaptor (st,sql).Excute();
		}
		catch(soci::soci_error& err)
		{
			LOG_ERROR << DataBase::GetSociErrorString(err) << L" During Erase LoginStatus Info";
		}
#endif

	}

	void	Erase( int32_t userID, CodecProtocol::EClientType cType, int32_t status )
	{
		try
		{
			using namespace autoDB;

			auto& sql = DataBase::GetInstance().GetNameSession("SafeIDMap::Erase");
			Statement st;

			st.Update(SV_UserLoginStatusInfo.LoginStatus.Use(DBValue::LoginStatus::Logout))
				.Where(SV_UserLoginStatusInfo.LoginType==static_cast<int32_t>(cType) &&
				SV_UserLoginStatusInfo.LoginStatus==DBValue::LoginStatus::Login &&
				SV_UserLoginStatusInfo.UserID==userID);

			SociAdaptor(st,sql).Excute();
			
			LOG_INFO << L"[UserMap]" << userID << L"(" << static_cast<int>(cType) << L") Has Logout";
		}
		catch(soci::soci_error& err)
		{
			LOG_ERROR << L"[UserMap]" << DataBase::GetSociErrorString(err) << L" During Erase VerifyCode For " << userID;
		}
		
	}

public:

	typedef	std::unordered_set<AStringType>	IgnoreMsg;

	VCodeToIDMap	VCodeToIDMap_;
	EPToIDMap		EPToIDMap_;
	std::mutex		Mutex_;
	IgnoreMsg		IgnoreNames_;

	AStringType		CommonPubKey_;
	AStringType		CommonPriKey_;
};

SafeIDMap::SafeIDMap(PrivateCreator):ImpUPtr_(smartPtr::make_unique<SafeIDMap::Imp>())
{

}

SafeIDMap::~SafeIDMap()
{

}

bool		SafeIDMap::Verify( const Codec::SDecodeContext& dc, const mori::EndPoint& remoteEP )
{
	const auto& ignore = ImpUPtr_->IgnoreNames_;
	if ( ignore.find(dc.MsgName_) != ignore.end() )
	{
		return true;
	}

	if ( !dc.UserID_ || !dc.VerifyCode_ )
	{
		if ( dc.UserID_ )
		{
			LOG_INFO << L"[UserMap] VerifyCode is empty." << L" UserID:" << *dc.UserID_ << L", CType:" << static_cast<int>(dc.ClientType_) << remoteEP;;
		}
		else if ( dc.VerifyCode_ )
		{
			LOG_INFO << L"[UserMap] UserID is empty." << DecodeVCode(*dc.VerifyCode_) << remoteEP;
		}
		else
		{
			LOG_INFO << L"[UserMap] UserID and VerifyCode are empty." << remoteEP;;
		}

		return false;
	}

	const auto& userID		= *dc.UserID_;
	const auto& verifyCode	= *dc.VerifyCode_;

	{
		std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

		auto& vCodeToID_ = ImpUPtr_->VCodeToIDMap_;
		auto& epToID_	= ImpUPtr_->EPToIDMap_.by<EP>();

		auto itorVerify = vCodeToID_.find(verifyCode);
		if ( itorVerify == vCodeToID_.end() )
		{
			LOG_INFO << L"[UserMap] " << L"can't find info for" << DecodeVCode(*dc.VerifyCode_) << remoteEP;
			return false;
		}

		if ( itorVerify->second->UserID_ != userID || itorVerify->second->ClientType_ != dc.ClientType_ )
		{
			LOG_INFO << L"[UserMap] " << L"info doesn't match for " << DecodeVCode(*dc.VerifyCode_)
				<< L", Expect" <<DecodeVCode(itorVerify->first);

			return false;
		}

		auto itorEP = epToID_.find(remoteEP);
		if ( itorEP == epToID_.end() )
		{
			LOG_INFO << L"[UserMap]" << L"Add" << remoteEP << L"For " << DecodeVCode(itorVerify->first);
			epToID_.insert(std::make_pair(remoteEP, SIDInfoWPtr(itorVerify->second)));
		}
	}
	
	return true;
}

void SafeIDMap::Insert( const SIDInfoSPtr& idinfo, const mori::EndPoint& remoteEP )
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	auto& vCodeToID_ = ImpUPtr_->VCodeToIDMap_;
	auto& epToID_	= ImpUPtr_->EPToIDMap_.by<EP>();

	LOG_INFO << L"[UserMap]" << L"Create" << remoteEP << L"For " << DecodeVCode(idinfo->VerifyCode_);

	vCodeToID_.emplace(idinfo->VerifyCode_, idinfo);
	epToID_.insert(std::make_pair(remoteEP, SIDInfoWPtr(idinfo)));
}



void							SafeIDMap::Clear()
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	ImpUPtr_->VCodeToIDMap_.clear();
	ImpUPtr_->EPToIDMap_.clear();
}

SIDInfoSPtr		SafeIDMap::GetIDInfo( const AStringType& verifyCode )
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	auto& infos = ImpUPtr_->VCodeToIDMap_;

	auto itor = infos.find(verifyCode);
	if ( itor != infos.end() )
	{
		return itor->second;
	}
	else
	{
		return SIDInfoSPtr();
	}
}

SIDInfoSPtr		SafeIDMap::GetIDInfo( const mori::EndPoint& endPoint )
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	auto& endpoints = ImpUPtr_->EPToIDMap_.by<EP>();

	auto itorEP = endpoints.find(endPoint);
	if ( itorEP == endpoints.end() )
	{
		return SIDInfoSPtr();
	}

	return itorEP->second.lock();
}

void SafeIDMap::EraseConnection( const mori::EndPoint& remoteEP )
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	auto& endpoints	= ImpUPtr_->EPToIDMap_.by<EP>();
	auto& infos = ImpUPtr_->VCodeToIDMap_;

	auto itorEP = endpoints.find(remoteEP);
	if ( itorEP == endpoints.end() )
	{
		LOG_INFO << L"[UserMap]" << remoteEP << L"Do Not Exist";
		return;
	}

	auto idWPtr = itorEP->second;
	endpoints.erase(itorEP);

	auto& ids_ = ImpUPtr_->EPToIDMap_.by<IDWPtr>();
	if ( 0 != ids_.count(idWPtr) )
	{
		return;
	}

	auto idSPtr = idWPtr.lock();

	if ( !idSPtr )
	{
		LOG_ERROR << L"[UserMap]" << L"Lost UserInfo For" << remoteEP;
		return;
	}

	LOG_INFO << L"[UserMap]" << L"Erase UserInfo For" << remoteEP << L"(" << DecodeVCode(idSPtr->VerifyCode_) << L")";

	ImpUPtr_->Erase(idSPtr->UserID_, idSPtr->ClientType_, DBValue::LoginStatus::Except);
	infos.erase(idSPtr->VerifyCode_);
}

void SafeIDMap::EraseVerifyCode(const AStringType& veriCode)
{
	std::lock_guard<std::mutex> lock(ImpUPtr_->Mutex_);

	auto& infos = ImpUPtr_->VCodeToIDMap_;
	auto& usercodes = ImpUPtr_->EPToIDMap_.by<IDWPtr>();

	auto itorUserInfo = infos.find(veriCode);
	if ( itorUserInfo == infos.end() )
	{
		return;
	}

	ImpUPtr_->Erase(itorUserInfo->second->UserID_, itorUserInfo->second->ClientType_, DBValue::LoginStatus::Logout);

	usercodes.erase(SIDInfoWPtr(itorUserInfo->second));
	infos.erase(itorUserInfo);
}

const AStringType& SafeIDMap::GetCommonPublicKey() const
{
	return ImpUPtr_->CommonPubKey_;
}

const AStringType& SafeIDMap::GetCommonPrivateKey() const
{
	return ImpUPtr_->CommonPriKey_;
}

void SafeIDMap::AddIgnoreName( const AStringType& name )
{
	ImpUPtr_->IgnoreNames_.insert(name);
}


SafeIDMap& SafeIDMap::GetInstance()
{
	if ( !sIntancePtr )
	{
		sIntancePtr = smartPtr::make_unique<SafeIDMap>(PrivateCreator());
	}
	
	return *sIntancePtr;
}

AStringType SafeIDMap::DecodeVCode( const AStringType& veriCode )
{
	UserVCode msg;
	if ( !msg.ParseFromString(veriCode) )
	{
		return "Error VCode!";
	}

	boost::format fmt("(UserID:%d,CType:%d,LoginTime:%s)");
	fmt % msg.userid() % static_cast<int>(msg.ctype());
	fmt % boost::posix_time::to_iso_string(boost::posix_time::ptime(boost::gregorian::date(1900,1,1), boost::posix_time::milliseconds(msg.logintime())));

	return fmt.str();
}

AStringType SafeIDMap::CreateVCode( int32_t userID, int32_t cType )
{
	UserVCode msg;
	msg.set_userid(userID);
	msg.set_ctype(static_cast<CodecProtocol::EClientType >(cType));
	msg.set_uid(s_VCodeUID.fetch_add(1));
	auto now = boost::posix_time::second_clock::local_time();
	auto eplased = (now-boost::posix_time::ptime(boost::gregorian::date(1900,1,1))).total_milliseconds();
	msg.set_logintime(eplased);

	return msg.SerializeAsString();
}
