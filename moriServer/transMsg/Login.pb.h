// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto__INCLUDED
#define PROTOBUF_Login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "EReturnStatus.pb.h"
#include "msg-GL.pb.h"
// @@protoc_insertion_point(includes)

namespace transMsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Login_2eproto();
void protobuf_AssignDesc_Login_2eproto();
void protobuf_ShutdownFile_Login_2eproto();

class QLogin;
class ALogin;

// ===================================================================

class QLogin : public ::google::protobuf::Message {
 public:
  QLogin();
  virtual ~QLogin();

  QLogin(const QLogin& from);

  inline QLogin& operator=(const QLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QLogin& default_instance();

  void Swap(QLogin* other);

  // implements Message ----------------------------------------------

  QLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QLogin& from);
  void MergeFrom(const QLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes UserCode = 1;
  inline bool has_usercode() const;
  inline void clear_usercode();
  static const int kUserCodeFieldNumber = 1;
  inline const ::std::string& usercode() const;
  inline void set_usercode(const ::std::string& value);
  inline void set_usercode(const char* value);
  inline void set_usercode(const void* value, size_t size);
  inline ::std::string* mutable_usercode();
  inline ::std::string* release_usercode();
  inline void set_allocated_usercode(::std::string* usercode);

  // required bytes UserPwd = 2;
  inline bool has_userpwd() const;
  inline void clear_userpwd();
  static const int kUserPwdFieldNumber = 2;
  inline const ::std::string& userpwd() const;
  inline void set_userpwd(const ::std::string& value);
  inline void set_userpwd(const char* value);
  inline void set_userpwd(const void* value, size_t size);
  inline ::std::string* mutable_userpwd();
  inline ::std::string* release_userpwd();
  inline void set_allocated_userpwd(::std::string* userpwd);

  // optional bytes PubRSAKey = 3;
  inline bool has_pubrsakey() const;
  inline void clear_pubrsakey();
  static const int kPubRSAKeyFieldNumber = 3;
  inline const ::std::string& pubrsakey() const;
  inline void set_pubrsakey(const ::std::string& value);
  inline void set_pubrsakey(const char* value);
  inline void set_pubrsakey(const void* value, size_t size);
  inline ::std::string* mutable_pubrsakey();
  inline ::std::string* release_pubrsakey();
  inline void set_allocated_pubrsakey(::std::string* pubrsakey);

  // @@protoc_insertion_point(class_scope:transMsg.QLogin)
 private:
  inline void set_has_usercode();
  inline void clear_has_usercode();
  inline void set_has_userpwd();
  inline void clear_has_userpwd();
  inline void set_has_pubrsakey();
  inline void clear_has_pubrsakey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* usercode_;
  ::std::string* userpwd_;
  ::std::string* pubrsakey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static QLogin* default_instance_;
};
// -------------------------------------------------------------------

class ALogin : public ::google::protobuf::Message {
 public:
  ALogin();
  virtual ~ALogin();

  ALogin(const ALogin& from);

  inline ALogin& operator=(const ALogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ALogin& default_instance();

  void Swap(ALogin* other);

  // implements Message ----------------------------------------------

  ALogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ALogin& from);
  void MergeFrom(const ALogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .transMsg.EReturnStatus Stats = 1;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 1;
  inline ::transMsg::EReturnStatus stats() const;
  inline void set_stats(::transMsg::EReturnStatus value);

  // optional bytes VerifyCode = 2;
  inline bool has_verifycode() const;
  inline void clear_verifycode();
  static const int kVerifyCodeFieldNumber = 2;
  inline const ::std::string& verifycode() const;
  inline void set_verifycode(const ::std::string& value);
  inline void set_verifycode(const char* value);
  inline void set_verifycode(const void* value, size_t size);
  inline ::std::string* mutable_verifycode();
  inline ::std::string* release_verifycode();
  inline void set_allocated_verifycode(::std::string* verifycode);

  // optional bytes PubRSAKey = 3;
  inline bool has_pubrsakey() const;
  inline void clear_pubrsakey();
  static const int kPubRSAKeyFieldNumber = 3;
  inline const ::std::string& pubrsakey() const;
  inline void set_pubrsakey(const ::std::string& value);
  inline void set_pubrsakey(const char* value);
  inline void set_pubrsakey(const void* value, size_t size);
  inline ::std::string* mutable_pubrsakey();
  inline ::std::string* release_pubrsakey();
  inline void set_allocated_pubrsakey(::std::string* pubrsakey);

  // optional .transMsg.GL_UserInfo GL_UserInfo = 101;
  inline bool has_gl_userinfo() const;
  inline void clear_gl_userinfo();
  static const int kGLUserInfoFieldNumber = 101;
  inline const ::transMsg::GL_UserInfo& gl_userinfo() const;
  inline ::transMsg::GL_UserInfo* mutable_gl_userinfo();
  inline ::transMsg::GL_UserInfo* release_gl_userinfo();
  inline void set_allocated_gl_userinfo(::transMsg::GL_UserInfo* gl_userinfo);

  // repeated .transMsg.GL_DeptInfo GL_DeptInfo = 102;
  inline int gl_deptinfo_size() const;
  inline void clear_gl_deptinfo();
  static const int kGLDeptInfoFieldNumber = 102;
  inline const ::transMsg::GL_DeptInfo& gl_deptinfo(int index) const;
  inline ::transMsg::GL_DeptInfo* mutable_gl_deptinfo(int index);
  inline ::transMsg::GL_DeptInfo* add_gl_deptinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::transMsg::GL_DeptInfo >&
      gl_deptinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::transMsg::GL_DeptInfo >*
      mutable_gl_deptinfo();

  // repeated .transMsg.GL_RoleRightInfo GL_RoleRightInfo = 103;
  inline int gl_rolerightinfo_size() const;
  inline void clear_gl_rolerightinfo();
  static const int kGLRoleRightInfoFieldNumber = 103;
  inline const ::transMsg::GL_RoleRightInfo& gl_rolerightinfo(int index) const;
  inline ::transMsg::GL_RoleRightInfo* mutable_gl_rolerightinfo(int index);
  inline ::transMsg::GL_RoleRightInfo* add_gl_rolerightinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::transMsg::GL_RoleRightInfo >&
      gl_rolerightinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::transMsg::GL_RoleRightInfo >*
      mutable_gl_rolerightinfo();

  // @@protoc_insertion_point(class_scope:transMsg.ALogin)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_verifycode();
  inline void clear_has_verifycode();
  inline void set_has_pubrsakey();
  inline void clear_has_pubrsakey();
  inline void set_has_gl_userinfo();
  inline void clear_has_gl_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* verifycode_;
  ::std::string* pubrsakey_;
  ::transMsg::GL_UserInfo* gl_userinfo_;
  ::google::protobuf::RepeatedPtrField< ::transMsg::GL_DeptInfo > gl_deptinfo_;
  ::google::protobuf::RepeatedPtrField< ::transMsg::GL_RoleRightInfo > gl_rolerightinfo_;
  int stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static ALogin* default_instance_;
};
// ===================================================================


// ===================================================================

// QLogin

// required bytes UserCode = 1;
inline bool QLogin::has_usercode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QLogin::set_has_usercode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QLogin::clear_has_usercode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QLogin::clear_usercode() {
  if (usercode_ != &::google::protobuf::internal::kEmptyString) {
    usercode_->clear();
  }
  clear_has_usercode();
}
inline const ::std::string& QLogin::usercode() const {
  return *usercode_;
}
inline void QLogin::set_usercode(const ::std::string& value) {
  set_has_usercode();
  if (usercode_ == &::google::protobuf::internal::kEmptyString) {
    usercode_ = new ::std::string;
  }
  usercode_->assign(value);
}
inline void QLogin::set_usercode(const char* value) {
  set_has_usercode();
  if (usercode_ == &::google::protobuf::internal::kEmptyString) {
    usercode_ = new ::std::string;
  }
  usercode_->assign(value);
}
inline void QLogin::set_usercode(const void* value, size_t size) {
  set_has_usercode();
  if (usercode_ == &::google::protobuf::internal::kEmptyString) {
    usercode_ = new ::std::string;
  }
  usercode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QLogin::mutable_usercode() {
  set_has_usercode();
  if (usercode_ == &::google::protobuf::internal::kEmptyString) {
    usercode_ = new ::std::string;
  }
  return usercode_;
}
inline ::std::string* QLogin::release_usercode() {
  clear_has_usercode();
  if (usercode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usercode_;
    usercode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QLogin::set_allocated_usercode(::std::string* usercode) {
  if (usercode_ != &::google::protobuf::internal::kEmptyString) {
    delete usercode_;
  }
  if (usercode) {
    set_has_usercode();
    usercode_ = usercode;
  } else {
    clear_has_usercode();
    usercode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes UserPwd = 2;
inline bool QLogin::has_userpwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QLogin::set_has_userpwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QLogin::clear_has_userpwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QLogin::clear_userpwd() {
  if (userpwd_ != &::google::protobuf::internal::kEmptyString) {
    userpwd_->clear();
  }
  clear_has_userpwd();
}
inline const ::std::string& QLogin::userpwd() const {
  return *userpwd_;
}
inline void QLogin::set_userpwd(const ::std::string& value) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(value);
}
inline void QLogin::set_userpwd(const char* value) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(value);
}
inline void QLogin::set_userpwd(const void* value, size_t size) {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  userpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QLogin::mutable_userpwd() {
  set_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    userpwd_ = new ::std::string;
  }
  return userpwd_;
}
inline ::std::string* QLogin::release_userpwd() {
  clear_has_userpwd();
  if (userpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userpwd_;
    userpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QLogin::set_allocated_userpwd(::std::string* userpwd) {
  if (userpwd_ != &::google::protobuf::internal::kEmptyString) {
    delete userpwd_;
  }
  if (userpwd) {
    set_has_userpwd();
    userpwd_ = userpwd;
  } else {
    clear_has_userpwd();
    userpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes PubRSAKey = 3;
inline bool QLogin::has_pubrsakey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QLogin::set_has_pubrsakey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QLogin::clear_has_pubrsakey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QLogin::clear_pubrsakey() {
  if (pubrsakey_ != &::google::protobuf::internal::kEmptyString) {
    pubrsakey_->clear();
  }
  clear_has_pubrsakey();
}
inline const ::std::string& QLogin::pubrsakey() const {
  return *pubrsakey_;
}
inline void QLogin::set_pubrsakey(const ::std::string& value) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(value);
}
inline void QLogin::set_pubrsakey(const char* value) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(value);
}
inline void QLogin::set_pubrsakey(const void* value, size_t size) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QLogin::mutable_pubrsakey() {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  return pubrsakey_;
}
inline ::std::string* QLogin::release_pubrsakey() {
  clear_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubrsakey_;
    pubrsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QLogin::set_allocated_pubrsakey(::std::string* pubrsakey) {
  if (pubrsakey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubrsakey_;
  }
  if (pubrsakey) {
    set_has_pubrsakey();
    pubrsakey_ = pubrsakey;
  } else {
    clear_has_pubrsakey();
    pubrsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ALogin

// required .transMsg.EReturnStatus Stats = 1;
inline bool ALogin::has_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ALogin::set_has_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ALogin::clear_has_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ALogin::clear_stats() {
  stats_ = 0;
  clear_has_stats();
}
inline ::transMsg::EReturnStatus ALogin::stats() const {
  return static_cast< ::transMsg::EReturnStatus >(stats_);
}
inline void ALogin::set_stats(::transMsg::EReturnStatus value) {
  assert(::transMsg::EReturnStatus_IsValid(value));
  set_has_stats();
  stats_ = value;
}

// optional bytes VerifyCode = 2;
inline bool ALogin::has_verifycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ALogin::set_has_verifycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ALogin::clear_has_verifycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ALogin::clear_verifycode() {
  if (verifycode_ != &::google::protobuf::internal::kEmptyString) {
    verifycode_->clear();
  }
  clear_has_verifycode();
}
inline const ::std::string& ALogin::verifycode() const {
  return *verifycode_;
}
inline void ALogin::set_verifycode(const ::std::string& value) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(value);
}
inline void ALogin::set_verifycode(const char* value) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(value);
}
inline void ALogin::set_verifycode(const void* value, size_t size) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ALogin::mutable_verifycode() {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  return verifycode_;
}
inline ::std::string* ALogin::release_verifycode() {
  clear_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verifycode_;
    verifycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ALogin::set_allocated_verifycode(::std::string* verifycode) {
  if (verifycode_ != &::google::protobuf::internal::kEmptyString) {
    delete verifycode_;
  }
  if (verifycode) {
    set_has_verifycode();
    verifycode_ = verifycode;
  } else {
    clear_has_verifycode();
    verifycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes PubRSAKey = 3;
inline bool ALogin::has_pubrsakey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ALogin::set_has_pubrsakey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ALogin::clear_has_pubrsakey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ALogin::clear_pubrsakey() {
  if (pubrsakey_ != &::google::protobuf::internal::kEmptyString) {
    pubrsakey_->clear();
  }
  clear_has_pubrsakey();
}
inline const ::std::string& ALogin::pubrsakey() const {
  return *pubrsakey_;
}
inline void ALogin::set_pubrsakey(const ::std::string& value) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(value);
}
inline void ALogin::set_pubrsakey(const char* value) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(value);
}
inline void ALogin::set_pubrsakey(const void* value, size_t size) {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  pubrsakey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ALogin::mutable_pubrsakey() {
  set_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    pubrsakey_ = new ::std::string;
  }
  return pubrsakey_;
}
inline ::std::string* ALogin::release_pubrsakey() {
  clear_has_pubrsakey();
  if (pubrsakey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubrsakey_;
    pubrsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ALogin::set_allocated_pubrsakey(::std::string* pubrsakey) {
  if (pubrsakey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubrsakey_;
  }
  if (pubrsakey) {
    set_has_pubrsakey();
    pubrsakey_ = pubrsakey;
  } else {
    clear_has_pubrsakey();
    pubrsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .transMsg.GL_UserInfo GL_UserInfo = 101;
inline bool ALogin::has_gl_userinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ALogin::set_has_gl_userinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ALogin::clear_has_gl_userinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ALogin::clear_gl_userinfo() {
  if (gl_userinfo_ != NULL) gl_userinfo_->::transMsg::GL_UserInfo::Clear();
  clear_has_gl_userinfo();
}
inline const ::transMsg::GL_UserInfo& ALogin::gl_userinfo() const {
  return gl_userinfo_ != NULL ? *gl_userinfo_ : *default_instance_->gl_userinfo_;
}
inline ::transMsg::GL_UserInfo* ALogin::mutable_gl_userinfo() {
  set_has_gl_userinfo();
  if (gl_userinfo_ == NULL) gl_userinfo_ = new ::transMsg::GL_UserInfo;
  return gl_userinfo_;
}
inline ::transMsg::GL_UserInfo* ALogin::release_gl_userinfo() {
  clear_has_gl_userinfo();
  ::transMsg::GL_UserInfo* temp = gl_userinfo_;
  gl_userinfo_ = NULL;
  return temp;
}
inline void ALogin::set_allocated_gl_userinfo(::transMsg::GL_UserInfo* gl_userinfo) {
  delete gl_userinfo_;
  gl_userinfo_ = gl_userinfo;
  if (gl_userinfo) {
    set_has_gl_userinfo();
  } else {
    clear_has_gl_userinfo();
  }
}

// repeated .transMsg.GL_DeptInfo GL_DeptInfo = 102;
inline int ALogin::gl_deptinfo_size() const {
  return gl_deptinfo_.size();
}
inline void ALogin::clear_gl_deptinfo() {
  gl_deptinfo_.Clear();
}
inline const ::transMsg::GL_DeptInfo& ALogin::gl_deptinfo(int index) const {
  return gl_deptinfo_.Get(index);
}
inline ::transMsg::GL_DeptInfo* ALogin::mutable_gl_deptinfo(int index) {
  return gl_deptinfo_.Mutable(index);
}
inline ::transMsg::GL_DeptInfo* ALogin::add_gl_deptinfo() {
  return gl_deptinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transMsg::GL_DeptInfo >&
ALogin::gl_deptinfo() const {
  return gl_deptinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::transMsg::GL_DeptInfo >*
ALogin::mutable_gl_deptinfo() {
  return &gl_deptinfo_;
}

// repeated .transMsg.GL_RoleRightInfo GL_RoleRightInfo = 103;
inline int ALogin::gl_rolerightinfo_size() const {
  return gl_rolerightinfo_.size();
}
inline void ALogin::clear_gl_rolerightinfo() {
  gl_rolerightinfo_.Clear();
}
inline const ::transMsg::GL_RoleRightInfo& ALogin::gl_rolerightinfo(int index) const {
  return gl_rolerightinfo_.Get(index);
}
inline ::transMsg::GL_RoleRightInfo* ALogin::mutable_gl_rolerightinfo(int index) {
  return gl_rolerightinfo_.Mutable(index);
}
inline ::transMsg::GL_RoleRightInfo* ALogin::add_gl_rolerightinfo() {
  return gl_rolerightinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transMsg::GL_RoleRightInfo >&
ALogin::gl_rolerightinfo() const {
  return gl_rolerightinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::transMsg::GL_RoleRightInfo >*
ALogin::mutable_gl_rolerightinfo() {
  return &gl_rolerightinfo_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace transMsg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto__INCLUDED
